<!DOCTYPE html><html><head><title>Koa - next generation web framework for node.js</title><link rel="stylesheet" href="public/style.css"><link rel="stylesheet" href="public/icons/css/slate.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Italiana&amp;subset=latin"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/styles/github.min.css"><meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"><script>window.analytics=window.analytics||[],window.analytics.methods=["identify","group","track","page","pageview","alias","ready","on","once","off","trackLink","trackForm","trackClick","trackSubmit"],window.analytics.factory=function(t){return function(){var a=Array.prototype.slice.call(arguments);return a.unshift(t),window.analytics.push(a),window.analytics}};for(var i=0;i<window.analytics.methods.length;i++){var key=window.analytics.methods[i];window.analytics[key]=window.analytics.factory(key)}window.analytics.load=function(t){if(!document.getElementById("analytics-js")){var a=document.createElement("script");a.type="text/javascript",a.id="analytics-js",a.async=!0,a.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.io/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n)}},window.analytics.SNIPPET_VERSION="2.0.9",
window.analytics.load("9u0xff0b3k");
window.analytics.page();</script><script src="stats.js"></script><script src="https://embed.runkit.com" async defer></script></head><body><section id="top"><div id="menu"><a id="toggle" href="#"><i class="icon-menu"></i></a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#application">Application</a></li><li><a href="#context">Context</a></li><li><a href="#request">Request</a></li><li><a href="#response">Response</a></li><li><a href="#links">Links</a></li></ul></div><div id="heading"><div id="logo">Koa</div><div id="tagline">next generation web framework for node.js</div></div></section><section><div class="content"><h1 id="introduction">Introduction</h1><p>Koa is a new web framework designed by the team behind Express,
which aims to be a smaller, more expressive, and more robust foundation
for web applications and APIs. By leveraging async functions, Koa allows you
to ditch callbacks and greatly increase error-handling. Koa does not bundle any
middleware within its core, and it provides an elegant suite of methods that make
writing servers fast and enjoyable.
</p></div></section><section><div class="content"><h1 id="installation">Installation</h1>
<p>  Koa requires <strong>node v7.6.0</strong> or higher for ES2015 and async function support.</p>
<p>  You can quickly install a supported version of node with your favorite version manager:</p>
<div id = "example-0"><pre><code class = "lang-bash">$ nvm install 7
$ npm i koa
$ node my-koa-app.js</code></pre></div><h2 id="async-functions-with-babel">Async Functions with Babel</h2>
<p>To use <code>async</code> functions in Koa in versions of node &lt; 7.6, we recommend using <a href="http://babeljs.io/docs/usage/babel-register/">babel&#39;s require hook</a>.</p>
<div id = "example-1"><pre><code class = "lang-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-register'</span>);
<span class="hljs-comment">// require the rest of the app that needs to be transpiled after the hook</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./app'</span>);</code></pre></div><p>To parse and transpile async functions,
you should at a minimum have the <a href="http://babeljs.io/docs/plugins/transform-async-to-generator/">transform-async-to-generator</a>
or <a href="http://babeljs.io/docs/plugins/transform-async-to-module-method/">transform-async-to-module-method</a> plugins.
For example, in your <code>.babelrc</code> file, you should have:</p>
<div id = "example-2"><pre><code class = "lang-json">{
  <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-async-to-generator"</span>]
}</code></pre></div><p>You can also use the <a href="http://babeljs.io/docs/plugins/preset-env/">env preset</a> with a target option <code>&quot;node&quot;: &quot;current&quot;</code> instead.</p>
<h1 id="application">Application</h1>
<p>  A Koa application is an object containing an array of middleware functions
  which are composed and executed in a stack-like manner upon request. Koa is similar to many
  other middleware systems that you may have encountered such as Ruby&#39;s Rack, Connect, and so on -
  however a key design decision was made to provide high level &quot;sugar&quot; at the otherwise low-level
  middleware layer. This improves interoperability, robustness, and makes writing middleware much
  more enjoyable.</p>
<p>  This includes methods for common tasks like content-negotiation, cache freshness, proxy support, and redirection
  among others. Despite supplying a reasonably large number of helpful methods Koa maintains a small footprint, as
  no middleware are bundled.</p>
<p>  The obligatory hello world application:</p>
<!-- runkit:endpoint -->
<div id = "example-3"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();

app.use(<span class="hljs-keyword">async</span> ctx =&gt; {
  ctx.body = <span class="hljs-string">'Hello World'</span>;
});

app.listen(<span class="hljs-number">3000</span>);</code></pre></div><script>(function endpoint(id, count) {
            
                if (!window.RunKit)
                    if (typeof count === "undefined" || count < 20)
                        return setTimeout(endpoint, 500, id, count || 0 + 1);
                    else
                        return;

                var parent = document.getElementById(id);
                var source = parent.textContent;
                
                parent.innerHTML = "";

                RunKit.createNotebook({
                    element: parent,
                    nodeVersion: "8.x.x",
                    source: source,
                    mode: "endpoint"
                });
            })("example-3")</script><h2 id="cascading">Cascading</h2>
<p>  Koa middleware cascade in a more traditional way as you may be used to with similar tools -
  this was previously difficult to make user friendly with node&#39;s use of callbacks.
  However with async functions we can achieve &quot;true&quot; middleware. Contrasting Connect&#39;s implementation which
  simply passes control through series of functions until one returns, Koa invoke &quot;downstream&quot;, then
  control flows back &quot;upstream&quot;.</p>
<p>  The following example responds with &quot;Hello World&quot;, however first the request flows through
  the <code>x-response-time</code> and <code>logging</code> middleware to mark when the request started, then continue
  to yield control through the response middleware. When a middleware invokes <code>next()</code>
  the function suspends and passes control to the next middleware defined. After there are no more
  middleware to execute downstream, the stack will unwind and each middleware is resumed to perform
  its upstream behaviour.</p>
<!-- runkit:endpoint -->
<div id = "example-4"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();

<span class="hljs-comment">// logger</span>

app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">await</span> next();
  <span class="hljs-keyword">const</span> rt = ctx.response.get(<span class="hljs-string">'X-Response-Time'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${ctx.method}</span> <span class="hljs-subst">${ctx.url}</span> - <span class="hljs-subst">${rt}</span>`</span>);
});

<span class="hljs-comment">// x-response-time</span>

app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">await</span> next();
  <span class="hljs-keyword">const</span> ms = <span class="hljs-built_in">Date</span>.now() - start;
  ctx.set(<span class="hljs-string">'X-Response-Time'</span>, <span class="hljs-string">`<span class="hljs-subst">${ms}</span>ms`</span>);
});

<span class="hljs-comment">// response</span>

app.use(<span class="hljs-keyword">async</span> ctx =&gt; {
  ctx.body = <span class="hljs-string">'Hello World'</span>;
});

app.listen(<span class="hljs-number">3000</span>);</code></pre></div><script>(function endpoint(id, count) {
            
                if (!window.RunKit)
                    if (typeof count === "undefined" || count < 20)
                        return setTimeout(endpoint, 500, id, count || 0 + 1);
                    else
                        return;

                var parent = document.getElementById(id);
                var source = parent.textContent;
                
                parent.innerHTML = "";

                RunKit.createNotebook({
                    element: parent,
                    nodeVersion: "8.x.x",
                    source: source,
                    mode: "endpoint"
                });
            })("example-4")</script><h2 id="settings">Settings</h2>
<p>  Application settings are properties on the <code>app</code> instance, currently
  the following are supported:</p>
<ul>
<li><code>app.env</code> defaulting to the <strong>NODE_ENV</strong> or &quot;development&quot;</li>
<li><code>app.proxy</code> when true proxy header fields will be trusted</li>
<li><code>app.subdomainOffset</code> offset of <code>.subdomains</code> to ignore [2]</li>
</ul>
<h2 id="app-listen-">app.listen(...)</h2>
<p>  A Koa application is not a 1-to-1 representation of an HTTP server.
  One or more Koa applications may be mounted together to form larger
  applications with a single HTTP server.</p>
<p>  Create and return an HTTP server, passing the given arguments to
  <code>Server#listen()</code>. These arguments are documented on <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">nodejs.org</a>. The following is a useless Koa application bound to port <code>3000</code>:</p>
<div id = "example-5"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
app.listen(<span class="hljs-number">3000</span>);</code></pre></div><p>  The <code>app.listen(...)</code> method is simply sugar for the following:</p>
<div id = "example-6"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
http.createServer(app.callback()).listen(<span class="hljs-number">3000</span>);</code></pre></div><p>  This means you can spin up the same application as both HTTP and HTTPS
  or on multiple addresses:</p>
<div id = "example-7"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">'https'</span>);
<span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
http.createServer(app.callback()).listen(<span class="hljs-number">3000</span>);
https.createServer(app.callback()).listen(<span class="hljs-number">3001</span>);</code></pre></div><h2 id="app-callback-">app.callback()</h2>
<p>  Return a callback function suitable for the <code>http.createServer()</code>
  method to handle a request.
  You may also use this callback function to mount your Koa app in a
  Connect/Express app.</p>
<h2 id="app-use-function-">app.use(function)</h2>
<p>  Add the given middleware function to this application. See <a href="https://github.com/koajs/koa/wiki#middleware">Middleware</a> for
  more information.</p>
<h2 id="app-keys-">app.keys=</h2>
<p> Set signed cookie keys.</p>
<p> These are passed to <a href="https://github.com/jed/keygrip">KeyGrip</a>,
 however you may also pass your own <code>KeyGrip</code> instance. For
 example the following are acceptable:</p>
<div id = "example-8"><pre><code class = "lang-js">app.keys = [<span class="hljs-string">'im a newer secret'</span>, <span class="hljs-string">'i like turtle'</span>];
app.keys = <span class="hljs-keyword">new</span> KeyGrip([<span class="hljs-string">'im a newer secret'</span>, <span class="hljs-string">'i like turtle'</span>], <span class="hljs-string">'sha256'</span>);</code></pre></div><p>  These keys may be rotated and are used when signing cookies
  with the <code>{ signed: true }</code> option:</p>
<div id = "example-9"><pre><code class = "lang-js">ctx.cookies.set(<span class="hljs-string">'name'</span>, <span class="hljs-string">'tobi'</span>, { <span class="hljs-attr">signed</span>: <span class="hljs-literal">true</span> });</code></pre></div><h2 id="app-context">app.context</h2>
<p>  <code>app.context</code> is the prototype from which <code>ctx</code> is created.
  You may add additional properties to <code>ctx</code> by editing <code>app.context</code>.
  This is useful for adding properties or methods to <code>ctx</code> to be used across your entire app,
  which may be more performant (no middleware) and/or easier (fewer <code>require()</code>s)
  at the expense of relying more on <code>ctx</code>, which could be considered an anti-pattern.</p>
<p>  For example, to add a reference to your database from <code>ctx</code>:</p>
<div id = "example-10"><pre><code class = "lang-js">app.context.db = db();

app.use(<span class="hljs-keyword">async</span> ctx =&gt; {
  <span class="hljs-built_in">console</span>.log(ctx.db);
});</code></pre></div><p>Note:</p>
<ul>
<li>Many properties on <code>ctx</code> are defined using getters, setters, and <code>Object.defineProperty()</code>. You can only edit these properties (not recommended) by using <code>Object.defineProperty()</code> on <code>app.context</code>. See <a href="https://github.com/koajs/koa/issues/652">https://github.com/koajs/koa/issues/652</a>.</li>
<li>Mounted apps currently use their parent&#39;s <code>ctx</code> and settings. Thus, mounted apps are really just groups of middleware.</li>
</ul>
<h2 id="error-handling">Error Handling</h2>
<p>  By default outputs all errors to stderr unless <code>app.silent</code> is <code>true</code>.
  The default error handler also won&#39;t output errors when <code>err.status</code> is <code>404</code> or <code>err.expose</code> is <code>true</code>.
  To perform custom error-handling logic such as centralized logging you can add an &quot;error&quot; event listener:</p>
<div id = "example-11"><pre><code class = "lang-js">app.on(<span class="hljs-string">'error'</span>, err =&gt; {
  log.error(<span class="hljs-string">'server error'</span>, err)
});</code></pre></div><p>  If an error is in the req/res cycle and it is <em>not</em> possible to respond to the client, the <code>Context</code> instance is also passed:</p>
<div id = "example-12"><pre><code class = "lang-js">app.on(<span class="hljs-string">'error'</span>, (err, ctx) =&gt; {
  log.error(<span class="hljs-string">'server error'</span>, err, ctx)
});</code></pre></div><p>  When an error occurs <em>and</em> it is still possible to respond to the client, aka no data has been written to the socket, Koa will respond
  appropriately with a 500 &quot;Internal Server Error&quot;. In either case
  an app-level &quot;error&quot; is emitted for logging purposes.</p>
</div></section><section><div class="content"><h1 id="context">Context</h1>
<p>  A Koa Context encapsulates node&#39;s <code>request</code> and <code>response</code> objects
  into a single object which provides many helpful methods for writing
  web applications and APIs.
  These operations are used so frequently in HTTP server development
  that they are added at this level instead of a higher level framework,
  which would force middleware to re-implement this common functionality.</p>
<p>  A <code>Context</code> is created <em>per</em> request, and is referenced in middleware
  as the receiver, or the <code>ctx</code> identifier, as shown in the following
  snippet:</p>
<div id = "example-13"><pre><code class = "lang-js">app.use(<span class="hljs-keyword">async</span> ctx =&gt; {
  ctx; <span class="hljs-comment">// is the Context</span>
  ctx.request; <span class="hljs-comment">// is a Koa Request</span>
  ctx.response; <span class="hljs-comment">// is a Koa Response</span>
});</code></pre></div><p>  Many of the context&#39;s accessors and methods simply delegate to their <code>ctx.request</code> or <code>ctx.response</code>
  equivalents for convenience, and are otherwise identical. For example <code>ctx.type</code> and <code>ctx.length</code>
  delegate to the <code>response</code> object, and <code>ctx.path</code> and <code>ctx.method</code> delegate to the <code>request</code>.</p>
<h2 id="api">API</h2>
<p>  <code>Context</code> specific methods and accessors.</p>
<h3 id="ctx-req">ctx.req</h3>
<p>  Node&#39;s <code>request</code> object.</p>
<h3 id="ctx-res">ctx.res</h3>
<p>  Node&#39;s <code>response</code> object.</p>
<p>  Bypassing Koa&#39;s response handling is <strong>not supported</strong>. Avoid using the following node properties:</p>
<ul>
<li><code>res.statusCode</code></li>
<li><code>res.writeHead()</code></li>
<li><code>res.write()</code></li>
<li><code>res.end()</code></li>
</ul>
<h3 id="ctx-request">ctx.request</h3>
<p>  A Koa <code>Request</code> object.</p>
<h3 id="ctx-response">ctx.response</h3>
<p>  A Koa <code>Response</code> object.</p>
<h3 id="ctx-state">ctx.state</h3>
<p>  The recommended namespace for passing information through middleware and to your frontend views.</p>
<div id = "example-14"><pre><code class = "lang-js">ctx.state.user = <span class="hljs-keyword">await</span> User.find(id);</code></pre></div><h3 id="ctx-app">ctx.app</h3>
<p>  Application instance reference.</p>
<h3 id="ctx-cookies-get-name-options-">ctx.cookies.get(name, [options])</h3>
<p>  Get cookie <code>name</code> with <code>options</code>:</p>
<ul>
<li><code>signed</code> the cookie requested should be signed</li>
</ul>
<p>Koa uses the <a href="https://github.com/jed/cookies">cookies</a> module where options are simply passed.</p>
<h3 id="ctx-cookies-set-name-value-options-">ctx.cookies.set(name, value, [options])</h3>
<p>  Set cookie <code>name</code> to <code>value</code> with <code>options</code>:</p>
<ul>
<li><code>maxAge</code> a number representing the milliseconds from Date.now() for expiry</li>
<li><code>signed</code> sign the cookie value</li>
<li><code>expires</code> a <code>Date</code> for cookie expiration</li>
<li><code>path</code> cookie path, <code>/&#39;</code> by default</li>
<li><code>domain</code> cookie domain</li>
<li><code>secure</code> secure cookie</li>
<li><code>httpOnly</code> server-accessible cookie, <strong>true</strong> by default</li>
<li><code>overwrite</code> a boolean indicating whether to overwrite previously set cookies of the same name (<strong>false</strong> by default). If this is true, all cookies set during the same request with the same name (regardless of path or domain) are filtered out of the Set-Cookie header when setting this cookie.</li>
</ul>
<p>Koa uses the <a href="https://github.com/jed/cookies">cookies</a> module where options are simply passed.</p>
<h3 id="ctx-throw-status-msg-properties-">ctx.throw([status], [msg], [properties])</h3>
<p>  Helper method to throw an error with a <code>.status</code> property
  defaulting to <code>500</code> that will allow Koa to respond appropriately.
  The following combinations are allowed:</p>
<div id = "example-15"><pre><code class = "lang-js">ctx.throw(<span class="hljs-number">400</span>);
ctx.throw(<span class="hljs-number">400</span>, <span class="hljs-string">'name required'</span>);
ctx.throw(<span class="hljs-number">400</span>, <span class="hljs-string">'name required'</span>, { <span class="hljs-attr">user</span>: user });</code></pre></div><p>  For example <code>ctx.throw(400, &#39;name required&#39;)</code> is equivalent to:</p>
<div id = "example-16"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'name required'</span>);
err.status = <span class="hljs-number">400</span>;
err.expose = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">throw</span> err;</code></pre></div><p>  Note that these are user-level errors and are flagged with
  <code>err.expose</code> meaning the messages are appropriate for
  client responses, which is typically not the case for
  error messages since you do not want to leak failure
  details.</p>
<p>  You may optionally pass a <code>properties</code> object which is merged into the error as-is, useful for decorating machine-friendly errors which are reported to the requester upstream.</p>
<div id = "example-17"><pre><code class = "lang-js">ctx.throw(<span class="hljs-number">401</span>, <span class="hljs-string">'access_denied'</span>, { <span class="hljs-attr">user</span>: user });</code></pre></div><p>Koa uses <a href="https://github.com/jshttp/http-errors">http-errors</a> to create errors.</p>
<h3 id="ctx-assert-value-status-msg-properties-">ctx.assert(value, [status], [msg], [properties])</h3>
<p>  Helper method to throw an error similar to <code>.throw()</code>
  when <code>!value</code>. Similar to node&#39;s <a href="http://nodejs.org/api/assert.html">assert()</a>
  method.</p>
<div id = "example-18"><pre><code class = "lang-js">ctx.assert(ctx.state.user, <span class="hljs-number">401</span>, <span class="hljs-string">'User not found. Please login!'</span>);</code></pre></div><p>Koa uses <a href="https://github.com/jshttp/http-assert">http-assert</a> for assertions.</p>
<h3 id="ctx-respond">ctx.respond</h3>
<p>  To bypass Koa&#39;s built-in response handling, you may explicitly set <code>ctx.respond = false;</code>. Use this if you want to write to the raw <code>res</code> object instead of letting Koa handle the response for you.</p>
<p>  Note that using this is <strong>not</strong> supported by Koa. This may break intended functionality of Koa middleware and Koa itself. Using this property is considered a hack and is only a convenience to those wishing to use traditional <code>fn(req, res)</code> functions and middleware within Koa.</p>
<h2 id="request-aliases">Request aliases</h2>
<p>  The following accessors and alias <a href="#request">Request</a> equivalents:</p>
<ul>
<li><code>ctx.header</code></li>
<li><code>ctx.headers</code></li>
<li><code>ctx.method</code></li>
<li><code>ctx.method=</code></li>
<li><code>ctx.url</code></li>
<li><code>ctx.url=</code></li>
<li><code>ctx.originalUrl</code></li>
<li><code>ctx.origin</code></li>
<li><code>ctx.href</code></li>
<li><code>ctx.path</code></li>
<li><code>ctx.path=</code></li>
<li><code>ctx.query</code></li>
<li><code>ctx.query=</code></li>
<li><code>ctx.querystring</code></li>
<li><code>ctx.querystring=</code></li>
<li><code>ctx.host</code></li>
<li><code>ctx.hostname</code></li>
<li><code>ctx.fresh</code></li>
<li><code>ctx.stale</code></li>
<li><code>ctx.socket</code></li>
<li><code>ctx.protocol</code></li>
<li><code>ctx.secure</code></li>
<li><code>ctx.ip</code></li>
<li><code>ctx.ips</code></li>
<li><code>ctx.subdomains</code></li>
<li><code>ctx.is()</code></li>
<li><code>ctx.accepts()</code></li>
<li><code>ctx.acceptsEncodings()</code></li>
<li><code>ctx.acceptsCharsets()</code></li>
<li><code>ctx.acceptsLanguages()</code></li>
<li><code>ctx.get()</code></li>
</ul>
<h2 id="response-aliases">Response aliases</h2>
<p>  The following accessors and alias <a href="#response">Response</a> equivalents:</p>
<ul>
<li><code>ctx.body</code></li>
<li><code>ctx.body=</code></li>
<li><code>ctx.status</code></li>
<li><code>ctx.status=</code></li>
<li><code>ctx.message</code></li>
<li><code>ctx.message=</code></li>
<li><code>ctx.length=</code></li>
<li><code>ctx.length</code></li>
<li><code>ctx.type=</code></li>
<li><code>ctx.type</code></li>
<li><code>ctx.headerSent</code></li>
<li><code>ctx.redirect()</code></li>
<li><code>ctx.attachment()</code></li>
<li><code>ctx.set()</code></li>
<li><code>ctx.append()</code></li>
<li><code>ctx.remove()</code></li>
<li><code>ctx.lastModified=</code></li>
<li><code>ctx.etag=</code></li>
</ul>
</div></section><section><div class="content"><h1 id="request">Request</h1>
<p>  A Koa <code>Request</code> object is an abstraction on top of node&#39;s vanilla request object,
  providing additional functionality that is useful for every day HTTP server
  development.</p>
<h2 id="api">API</h2>
<h3 id="request-header">request.header</h3>
<p> Request header object.</p>
<h3 id="request-header-">request.header=</h3>
<p> Set request header object.</p>
<h3 id="request-headers">request.headers</h3>
<p> Request header object. Alias as <code>request.header</code>.</p>
<h3 id="request-headers-">request.headers=</h3>
<p>  Set request header object. Alias as <code>request.header=</code>.</p>
<h3 id="request-method">request.method</h3>
<p>  Request method.</p>
<h3 id="request-method-">request.method=</h3>
<p>  Set request method, useful for implementing middleware
  such as <code>methodOverride()</code>.</p>
<h3 id="request-length">request.length</h3>
<p>  Return request Content-Length as a number when present, or <code>undefined</code>.</p>
<h3 id="request-url">request.url</h3>
<p>  Get request URL.</p>
<h3 id="request-url-">request.url=</h3>
<p>  Set request URL, useful for url rewrites.</p>
<h3 id="request-originalurl">request.originalUrl</h3>
<p>  Get request original URL.</p>
<h3 id="request-origin">request.origin</h3>
<p>  Get origin of URL, include <code>protocol</code> and <code>host</code>.</p>
<div id = "example-19"><pre><code class = "lang-js">ctx.request.origin
<span class="hljs-comment">// =&gt; http://example.com</span></code></pre></div><h3 id="request-href">request.href</h3>
<p>  Get full request URL, include <code>protocol</code>, <code>host</code> and <code>url</code>.</p>
<div id = "example-20"><pre><code class = "lang-js">ctx.request.href;
<span class="hljs-comment">// =&gt; http://example.com/foo/bar?q=1</span></code></pre></div><h3 id="request-path">request.path</h3>
<p>  Get request pathname.</p>
<h3 id="request-path-">request.path=</h3>
<p>  Set request pathname and retain query-string when present.</p>
<h3 id="request-querystring">request.querystring</h3>
<p>  Get raw query string void of <code>?</code>.</p>
<h3 id="request-querystring-">request.querystring=</h3>
<p>  Set raw query string.</p>
<h3 id="request-search">request.search</h3>
<p>  Get raw query string with the <code>?</code>.</p>
<h3 id="request-search-">request.search=</h3>
<p>  Set raw query string.</p>
<h3 id="request-host">request.host</h3>
<p>  Get host (hostname:port) when present. Supports <code>X-Forwarded-Host</code>
  when <code>app.proxy</code> is <strong>true</strong>, otherwise <code>Host</code> is used.</p>
<h3 id="request-hostname">request.hostname</h3>
<p>  Get hostname when present. Supports <code>X-Forwarded-Host</code>
  when <code>app.proxy</code> is <strong>true</strong>, otherwise <code>Host</code> is used.</p>
<p>  If host is IPv6, Koa delegates parsing to
  <a href="https://nodejs.org/dist/latest-v8.x/docs/api/url.html#url_the_whatwg_url_api">WHATWG URL API</a>,
  <em>Note</em> This may impact performance.</p>
<h3 id="request-url">request.URL</h3>
<p>  Get WHATWG parsed URL object.</p>
<h3 id="request-type">request.type</h3>
<p>  Get request <code>Content-Type</code> void of parameters such as &quot;charset&quot;.</p>
<div id = "example-21"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> ct = ctx.request.type;
<span class="hljs-comment">// =&gt; "image/png"</span></code></pre></div><h3 id="request-charset">request.charset</h3>
<p>  Get request charset when present, or <code>undefined</code>:</p>
<div id = "example-22"><pre><code class = "lang-js">ctx.request.charset;
<span class="hljs-comment">// =&gt; "utf-8"</span></code></pre></div><h3 id="request-query">request.query</h3>
<p>  Get parsed query-string, returning an empty object when no
  query-string is present. Note that this getter does <em>not</em>
  support nested parsing.</p>
<p>  For example &quot;color=blue&amp;size=small&quot;:</p>
<div id = "example-23"><pre><code class = "lang-js">{
  <span class="hljs-attr">color</span>: <span class="hljs-string">'blue'</span>,
  <span class="hljs-attr">size</span>: <span class="hljs-string">'small'</span>
}</code></pre></div><h3 id="request-query-">request.query=</h3>
<p>  Set query-string to the given object. Note that this
  setter does <em>not</em> support nested objects.</p>
<div id = "example-24"><pre><code class = "lang-js">ctx.query = { <span class="hljs-attr">next</span>: <span class="hljs-string">'/login'</span> };</code></pre></div><h3 id="request-fresh">request.fresh</h3>
<p>  Check if a request cache is &quot;fresh&quot;, aka the contents have not changed. This
  method is for cache negotiation between <code>If-None-Match</code> / <code>ETag</code>, and <code>If-Modified-Since</code> and <code>Last-Modified</code>. It should be referenced after setting one or more of these response headers.</p>
<div id = "example-25"><pre><code class = "lang-js"><span class="hljs-comment">// freshness check requires status 20x or 304</span>
ctx.status = <span class="hljs-number">200</span>;
ctx.set(<span class="hljs-string">'ETag'</span>, <span class="hljs-string">'123'</span>);

<span class="hljs-comment">// cache is ok</span>
<span class="hljs-keyword">if</span> (ctx.fresh) {
  ctx.status = <span class="hljs-number">304</span>;
  <span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">// cache is stale</span>
<span class="hljs-comment">// fetch new data</span>
ctx.body = <span class="hljs-keyword">await</span> db.find(<span class="hljs-string">'something'</span>);</code></pre></div><h3 id="request-stale">request.stale</h3>
<p>  Inverse of <code>request.fresh</code>.</p>
<h3 id="request-protocol">request.protocol</h3>
<p>  Return request protocol, &quot;https&quot; or &quot;http&quot;. Supports <code>X-Forwarded-Proto</code>
  when <code>app.proxy</code> is <strong>true</strong>.</p>
<h3 id="request-secure">request.secure</h3>
<p>  Shorthand for <code>ctx.protocol == &quot;https&quot;</code> to check if a request was
  issued via TLS.</p>
<h3 id="request-ip">request.ip</h3>
<p>  Request remote address. Supports <code>X-Forwarded-For</code> when <code>app.proxy</code>
  is <strong>true</strong>.</p>
<h3 id="request-ips">request.ips</h3>
<p>  When <code>X-Forwarded-For</code> is present and <code>app.proxy</code> is enabled an array
  of these ips is returned, ordered from upstream -&gt; downstream. When disabled
  an empty array is returned.</p>
<h3 id="request-subdomains">request.subdomains</h3>
<p>  Return subdomains as an array.</p>
<p>  Subdomains are the dot-separated parts of the host before the main domain of
  the app. By default, the domain of the app is assumed to be the last two
  parts of the host. This can be changed by setting <code>app.subdomainOffset</code>.</p>
<p>  For example, if the domain is &quot;tobi.ferrets.example.com&quot;:
  If <code>app.subdomainOffset</code> is not set, <code>ctx.subdomains</code> is <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>.
  If <code>app.subdomainOffset</code> is 3, <code>ctx.subdomains</code> is <code>[&quot;tobi&quot;]</code>.</p>
<h3 id="request-is-types-">request.is(types...)</h3>
<p>  Check if the incoming request contains the &quot;Content-Type&quot;
  header field, and it contains any of the give mime <code>type</code>s.
  If there is no request body, <code>null</code> is returned.
  If there is no content type, or the match fails <code>false</code> is returned.
  Otherwise, it returns the matching content-type.</p>
<div id = "example-26"><pre><code class = "lang-js"><span class="hljs-comment">// With Content-Type: text/html; charset=utf-8</span>
ctx.is(<span class="hljs-string">'html'</span>); <span class="hljs-comment">// =&gt; 'html'</span>
ctx.is(<span class="hljs-string">'text/html'</span>); <span class="hljs-comment">// =&gt; 'text/html'</span>
ctx.is(<span class="hljs-string">'text/*'</span>, <span class="hljs-string">'text/html'</span>); <span class="hljs-comment">// =&gt; 'text/html'</span>

<span class="hljs-comment">// When Content-Type is application/json</span>
ctx.is(<span class="hljs-string">'json'</span>, <span class="hljs-string">'urlencoded'</span>); <span class="hljs-comment">// =&gt; 'json'</span>
ctx.is(<span class="hljs-string">'application/json'</span>); <span class="hljs-comment">// =&gt; 'application/json'</span>
ctx.is(<span class="hljs-string">'html'</span>, <span class="hljs-string">'application/*'</span>); <span class="hljs-comment">// =&gt; 'application/json'</span>

ctx.is(<span class="hljs-string">'html'</span>); <span class="hljs-comment">// =&gt; false</span></code></pre></div><p>  For example if you want to ensure that
  only images are sent to a given route:</p>
<div id = "example-27"><pre><code class = "lang-js"><span class="hljs-keyword">if</span> (ctx.is(<span class="hljs-string">'image/*'</span>)) {
  <span class="hljs-comment">// process</span>
} <span class="hljs-keyword">else</span> {
  ctx.throw(<span class="hljs-number">415</span>, <span class="hljs-string">'images only!'</span>);
}</code></pre></div><h3 id="content-negotiation">Content Negotiation</h3>
<p>  Koa&#39;s <code>request</code> object includes helpful content negotiation utilities powered by <a href="http://github.com/expressjs/accepts">accepts</a> and <a href="https://github.com/federomero/negotiator">negotiator</a>. These utilities are:</p>
<ul>
<li><code>request.accepts(types)</code></li>
<li><code>request.acceptsEncodings(types)</code></li>
<li><code>request.acceptsCharsets(charsets)</code></li>
<li><code>request.acceptsLanguages(langs)</code></li>
</ul>
<p>If no types are supplied, <strong>all</strong> acceptable types are returned.</p>
<p>If multiple types are supplied, the best match will be returned. If no matches are found, a <code>false</code> is returned, and you should send a <code>406 &quot;Not Acceptable&quot;</code> response to the client.</p>
<p>In the case of missing accept headers where any type is acceptable, the first type will be returned. Thus, the order of types you supply is important.</p>
<h3 id="request-accepts-types-">request.accepts(types)</h3>
<p>  Check if the given <code>type(s)</code> is acceptable, returning the best match when true, otherwise <code>false</code>. The <code>type</code> value may be one or more mime type string
  such as &quot;application/json&quot;, the extension name
  such as &quot;json&quot;, or an array <code>[&quot;json&quot;, &quot;html&quot;, &quot;text/plain&quot;]</code>.</p>
<div id = "example-28"><pre><code class = "lang-js"><span class="hljs-comment">// Accept: text/html</span>
ctx.accepts(<span class="hljs-string">'html'</span>);
<span class="hljs-comment">// =&gt; "html"</span>

<span class="hljs-comment">// Accept: text/*, application/json</span>
ctx.accepts(<span class="hljs-string">'html'</span>);
<span class="hljs-comment">// =&gt; "html"</span>
ctx.accepts(<span class="hljs-string">'text/html'</span>);
<span class="hljs-comment">// =&gt; "text/html"</span>
ctx.accepts(<span class="hljs-string">'json'</span>, <span class="hljs-string">'text'</span>);
<span class="hljs-comment">// =&gt; "json"</span>
ctx.accepts(<span class="hljs-string">'application/json'</span>);
<span class="hljs-comment">// =&gt; "application/json"</span>

<span class="hljs-comment">// Accept: text/*, application/json</span>
ctx.accepts(<span class="hljs-string">'image/png'</span>);
ctx.accepts(<span class="hljs-string">'png'</span>);
<span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// Accept: text/*;q=.5, application/json</span>
ctx.accepts([<span class="hljs-string">'html'</span>, <span class="hljs-string">'json'</span>]);
ctx.accepts(<span class="hljs-string">'html'</span>, <span class="hljs-string">'json'</span>);
<span class="hljs-comment">// =&gt; "json"</span>

<span class="hljs-comment">// No Accept header</span>
ctx.accepts(<span class="hljs-string">'html'</span>, <span class="hljs-string">'json'</span>);
<span class="hljs-comment">// =&gt; "html"</span>
ctx.accepts(<span class="hljs-string">'json'</span>, <span class="hljs-string">'html'</span>);
<span class="hljs-comment">// =&gt; "json"</span></code></pre></div><p>  You may call <code>ctx.accepts()</code> as many times as you like,
  or use a switch:</p>
<div id = "example-29"><pre><code class = "lang-js"><span class="hljs-keyword">switch</span> (ctx.accepts(<span class="hljs-string">'json'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'text'</span>)) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'json'</span>: <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">'html'</span>: <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>: <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>: ctx.throw(<span class="hljs-number">406</span>, <span class="hljs-string">'json, html, or text only'</span>);
}</code></pre></div><h3 id="request-acceptsencodings-encodings-">request.acceptsEncodings(encodings)</h3>
<p>  Check if <code>encodings</code> are acceptable, returning the best match when true, otherwise <code>false</code>. Note that you should include <code>identity</code> as one of the encodings!</p>
<div id = "example-30"><pre><code class = "lang-js"><span class="hljs-comment">// Accept-Encoding: gzip</span>
ctx.acceptsEncodings(<span class="hljs-string">'gzip'</span>, <span class="hljs-string">'deflate'</span>, <span class="hljs-string">'identity'</span>);
<span class="hljs-comment">// =&gt; "gzip"</span>

ctx.acceptsEncodings([<span class="hljs-string">'gzip'</span>, <span class="hljs-string">'deflate'</span>, <span class="hljs-string">'identity'</span>]);
<span class="hljs-comment">// =&gt; "gzip"</span></code></pre></div><p>  When no arguments are given all accepted encodings
  are returned as an array:</p>
<div id = "example-31"><pre><code class = "lang-js"><span class="hljs-comment">// Accept-Encoding: gzip, deflate</span>
ctx.acceptsEncodings();
<span class="hljs-comment">// =&gt; ["gzip", "deflate", "identity"]</span></code></pre></div><p>  Note that the <code>identity</code> encoding (which means no encoding) could be unacceptable if the client explicitly sends <code>identity;q=0</code>. Although this is an edge case, you should still handle the case where this method returns <code>false</code>.</p>
<h3 id="request-acceptscharsets-charsets-">request.acceptsCharsets(charsets)</h3>
<p>  Check if <code>charsets</code> are acceptable, returning
  the best match when true, otherwise <code>false</code>.</p>
<div id = "example-32"><pre><code class = "lang-js"><span class="hljs-comment">// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5</span>
ctx.acceptsCharsets(<span class="hljs-string">'utf-8'</span>, <span class="hljs-string">'utf-7'</span>);
<span class="hljs-comment">// =&gt; "utf-8"</span>

ctx.acceptsCharsets([<span class="hljs-string">'utf-7'</span>, <span class="hljs-string">'utf-8'</span>]);
<span class="hljs-comment">// =&gt; "utf-8"</span></code></pre></div><p>  When no arguments are given all accepted charsets
  are returned as an array:</p>
<div id = "example-33"><pre><code class = "lang-js"><span class="hljs-comment">// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5</span>
ctx.acceptsCharsets();
<span class="hljs-comment">// =&gt; ["utf-8", "utf-7", "iso-8859-1"]</span></code></pre></div><h3 id="request-acceptslanguages-langs-">request.acceptsLanguages(langs)</h3>
<p>  Check if <code>langs</code> are acceptable, returning
  the best match when true, otherwise <code>false</code>.</p>
<div id = "example-34"><pre><code class = "lang-js"><span class="hljs-comment">// Accept-Language: en;q=0.8, es, pt</span>
ctx.acceptsLanguages(<span class="hljs-string">'es'</span>, <span class="hljs-string">'en'</span>);
<span class="hljs-comment">// =&gt; "es"</span>

ctx.acceptsLanguages([<span class="hljs-string">'en'</span>, <span class="hljs-string">'es'</span>]);
<span class="hljs-comment">// =&gt; "es"</span></code></pre></div><p>  When no arguments are given all accepted languages
  are returned as an array:</p>
<div id = "example-35"><pre><code class = "lang-js"><span class="hljs-comment">// Accept-Language: en;q=0.8, es, pt</span>
ctx.acceptsLanguages();
<span class="hljs-comment">// =&gt; ["es", "pt", "en"]</span></code></pre></div><h3 id="request-idempotent">request.idempotent</h3>
<p>  Check if the request is idempotent.</p>
<h3 id="request-socket">request.socket</h3>
<p>  Return the request socket.</p>
<h3 id="request-get-field-">request.get(field)</h3>
<p>  Return request header.</p>
</div></section><section><div class="content"><h1 id="response">Response</h1>
<p>  A Koa <code>Response</code> object is an abstraction on top of node&#39;s vanilla response object,
  providing additional functionality that is useful for every day HTTP server
  development.</p>
<h2 id="api">API</h2>
<h3 id="response-header">response.header</h3>
<p>  Response header object.</p>
<h3 id="response-headers">response.headers</h3>
<p>  Response header object. Alias as <code>response.header</code>.</p>
<h3 id="response-socket">response.socket</h3>
<p>  Request socket.</p>
<h3 id="response-status">response.status</h3>
<p>  Get response status. By default, <code>response.status</code> is set to <code>404</code> unlike node&#39;s <code>res.statusCode</code> which defaults to <code>200</code>.</p>
<h3 id="response-status-">response.status=</h3>
<p>  Set response status via numeric code:</p>
<ul>
<li>100 &quot;continue&quot;</li>
<li>101 &quot;switching protocols&quot;</li>
<li>102 &quot;processing&quot;</li>
<li>200 &quot;ok&quot;</li>
<li>201 &quot;created&quot;</li>
<li>202 &quot;accepted&quot;</li>
<li>203 &quot;non-authoritative information&quot;</li>
<li>204 &quot;no content&quot;</li>
<li>205 &quot;reset content&quot;</li>
<li>206 &quot;partial content&quot;</li>
<li>207 &quot;multi-status&quot;</li>
<li>208 &quot;already reported&quot;</li>
<li>226 &quot;im used&quot;</li>
<li>300 &quot;multiple choices&quot;</li>
<li>301 &quot;moved permanently&quot;</li>
<li>302 &quot;found&quot;</li>
<li>303 &quot;see other&quot;</li>
<li>304 &quot;not modified&quot;</li>
<li>305 &quot;use proxy&quot;</li>
<li>307 &quot;temporary redirect&quot;</li>
<li>308 &quot;permanent redirect&quot;</li>
<li>400 &quot;bad request&quot;</li>
<li>401 &quot;unauthorized&quot;</li>
<li>402 &quot;payment required&quot;</li>
<li>403 &quot;forbidden&quot;</li>
<li>404 &quot;not found&quot;</li>
<li>405 &quot;method not allowed&quot;</li>
<li>406 &quot;not acceptable&quot;</li>
<li>407 &quot;proxy authentication required&quot;</li>
<li>408 &quot;request timeout&quot;</li>
<li>409 &quot;conflict&quot;</li>
<li>410 &quot;gone&quot;</li>
<li>411 &quot;length required&quot;</li>
<li>412 &quot;precondition failed&quot;</li>
<li>413 &quot;payload too large&quot;</li>
<li>414 &quot;uri too long&quot;</li>
<li>415 &quot;unsupported media type&quot;</li>
<li>416 &quot;range not satisfiable&quot;</li>
<li>417 &quot;expectation failed&quot;</li>
<li>418 &quot;I&#39;m a teapot&quot;</li>
<li>422 &quot;unprocessable entity&quot;</li>
<li>423 &quot;locked&quot;</li>
<li>424 &quot;failed dependency&quot;</li>
<li>426 &quot;upgrade required&quot;</li>
<li>428 &quot;precondition required&quot;</li>
<li>429 &quot;too many requests&quot;</li>
<li>431 &quot;request header fields too large&quot;</li>
<li>500 &quot;internal server error&quot;</li>
<li>501 &quot;not implemented&quot;</li>
<li>502 &quot;bad gateway&quot;</li>
<li>503 &quot;service unavailable&quot;</li>
<li>504 &quot;gateway timeout&quot;</li>
<li>505 &quot;http version not supported&quot;</li>
<li>506 &quot;variant also negotiates&quot;</li>
<li>507 &quot;insufficient storage&quot;</li>
<li>508 &quot;loop detected&quot;</li>
<li>510 &quot;not extended&quot;</li>
<li>511 &quot;network authentication required&quot;</li>
</ul>
<p><strong>NOTE</strong>: don&#39;t worry too much about memorizing these strings,
if you have a typo an error will be thrown, displaying this list
so you can make a correction.</p>
<h3 id="response-message">response.message</h3>
<p>  Get response status message. By default, <code>response.message</code> is
  associated with <code>response.status</code>.</p>
<h3 id="response-message-">response.message=</h3>
<p>  Set response status message to the given value.</p>
<h3 id="response-length-">response.length=</h3>
<p>  Set response Content-Length to the given value.</p>
<h3 id="response-length">response.length</h3>
<p>  Return response Content-Length as a number when present, or deduce
  from <code>ctx.body</code> when possible, or <code>undefined</code>.</p>
<h3 id="response-body">response.body</h3>
<p>  Get response body.</p>
<h3 id="response-body-">response.body=</h3>
<p>  Set response body to one of the following:</p>
<ul>
<li><code>string</code> written</li>
<li><code>Buffer</code> written</li>
<li><code>Stream</code> piped</li>
<li><code>Object</code> || <code>Array</code> json-stringified</li>
<li><code>null</code> no content response</li>
</ul>
<p>If <code>response.status</code> has not been set, Koa will automatically set the status to <code>200</code> or <code>204</code>.</p>
<h4 id="string">String</h4>
<p>  The Content-Type is defaulted to text/html or text/plain, both with
  a default charset of utf-8. The Content-Length field is also set.</p>
<h4 id="buffer">Buffer</h4>
<p>  The Content-Type is defaulted to application/octet-stream, and Content-Length
  is also set.</p>
<h4 id="stream">Stream</h4>
<p>  The Content-Type is defaulted to application/octet-stream.</p>
<p>  Whenever a stream is set as the response body, <code>.onerror</code> is automatically added as a listener to the <code>error</code> event to catch any errors.
  In addition, whenever the request is closed (even prematurely), the stream is destroyed.
  If you do not want these two features, do not set the stream as the body directly.
  For example, you may not want this when setting the body as an HTTP stream in a proxy as it would destroy the underlying connection.</p>
<p>  See: <a href="https://github.com/koajs/koa/pull/612">https://github.com/koajs/koa/pull/612</a> for more information.</p>
<p>  Here&#39;s an example of stream error handling without automatically destroying the stream:</p>
<div id = "example-36"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> PassThrough = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).PassThrough;

app.use(<span class="hljs-keyword">async</span> ctx =&gt; {
  ctx.body = someHTTPStream.on(<span class="hljs-string">'error'</span>, ctx.onerror).pipe(PassThrough());
});</code></pre></div><h4 id="object">Object</h4>
<p>  The Content-Type is defaulted to application/json. This includes plain objects <code>{ foo: &#39;bar&#39; }</code> and arrays <code>[&#39;foo&#39;, &#39;bar&#39;]</code>.</p>
<h3 id="response-get-field-">response.get(field)</h3>
<p>  Get a response header field value with case-insensitive <code>field</code>.</p>
<div id = "example-37"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> etag = ctx.response.get(<span class="hljs-string">'ETag'</span>);</code></pre></div><h3 id="response-set-field-value-">response.set(field, value)</h3>
<p>  Set response header <code>field</code> to <code>value</code>:</p>
<div id = "example-38"><pre><code class = "lang-js">ctx.set(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'no-cache'</span>);</code></pre></div><h3 id="response-append-field-value-">response.append(field, value)</h3>
<p>  Append additional header <code>field</code> with value <code>val</code>.</p>
<div id = "example-39"><pre><code class = "lang-js">ctx.append(<span class="hljs-string">'Link'</span>, <span class="hljs-string">'&lt;http://127.0.0.1/&gt;'</span>);</code></pre></div><h3 id="response-set-fields-">response.set(fields)</h3>
<p>  Set several response header <code>fields</code> with an object:</p>
<div id = "example-40"><pre><code class = "lang-js">ctx.set({
  <span class="hljs-string">'Etag'</span>: <span class="hljs-string">'1234'</span>,
  <span class="hljs-string">'Last-Modified'</span>: date
});</code></pre></div><h3 id="response-remove-field-">response.remove(field)</h3>
<p>  Remove header <code>field</code>.</p>
<h3 id="response-type">response.type</h3>
<p>  Get response <code>Content-Type</code> void of parameters such as &quot;charset&quot;.</p>
<div id = "example-41"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> ct = ctx.type;
<span class="hljs-comment">// =&gt; "image/png"</span></code></pre></div><h3 id="response-type-">response.type=</h3>
<p>  Set response <code>Content-Type</code> via mime string or file extension.</p>
<div id = "example-42"><pre><code class = "lang-js">ctx.type = <span class="hljs-string">'text/plain; charset=utf-8'</span>;
ctx.type = <span class="hljs-string">'image/png'</span>;
ctx.type = <span class="hljs-string">'.png'</span>;
ctx.type = <span class="hljs-string">'png'</span>;</code></pre></div><p>  Note: when appropriate a <code>charset</code> is selected for you, for
  example <code>response.type = &#39;html&#39;</code> will default to &quot;utf-8&quot;. If you need to overwrite <code>charset</code>,
  use <code>ctx.set(&#39;Content-Type&#39;, &#39;text/html&#39;)</code> to set response header field to value directly.</p>
<h3 id="response-is-types-">response.is(types...)</h3>
<p>  Very similar to <code>ctx.request.is()</code>.
  Check whether the response type is one of the supplied types.
  This is particularly useful for creating middleware that
  manipulate responses.</p>
<p>  For example, this is a middleware that minifies
  all HTML responses except for streams.</p>
<div id = "example-43"><pre><code class = "lang-js"><span class="hljs-keyword">const</span> minify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-minifier'</span>);

app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">await</span> next();

  <span class="hljs-keyword">if</span> (!ctx.response.is(<span class="hljs-string">'html'</span>)) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">let</span> body = ctx.body;
  <span class="hljs-keyword">if</span> (!body || body.pipe) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">if</span> (Buffer.isBuffer(body)) body = body.toString();
  ctx.body = minify(body);
});</code></pre></div><h3 id="response-redirect-url-alt-">response.redirect(url, [alt])</h3>
<p>  Perform a [302] redirect to <code>url</code>.</p>
<p>  The string &quot;back&quot; is special-cased
  to provide Referrer support, when Referrer
  is not present <code>alt</code> or &quot;/&quot; is used.</p>
<div id = "example-44"><pre><code class = "lang-js">ctx.redirect(<span class="hljs-string">'back'</span>);
ctx.redirect(<span class="hljs-string">'back'</span>, <span class="hljs-string">'/index.html'</span>);
ctx.redirect(<span class="hljs-string">'/login'</span>);
ctx.redirect(<span class="hljs-string">'http://google.com'</span>);</code></pre></div><p>  To alter the default status of <code>302</code>, simply assign the status
  before or after this call. To alter the body, assign it after this call:</p>
<div id = "example-45"><pre><code class = "lang-js">ctx.status = <span class="hljs-number">301</span>;
ctx.redirect(<span class="hljs-string">'/cart'</span>);
ctx.body = <span class="hljs-string">'Redirecting to shopping cart'</span>;</code></pre></div><h3 id="response-attachment-filename-">response.attachment([filename])</h3>
<p>  Set <code>Content-Disposition</code> to &quot;attachment&quot; to signal the client
  to prompt for download. Optionally specify the <code>filename</code> of the
  download.</p>
<h3 id="response-headersent">response.headerSent</h3>
<p>  Check if a response header has already been sent. Useful for seeing
  if the client may be notified on error.</p>
<h3 id="response-lastmodified">response.lastModified</h3>
<p>  Return the <code>Last-Modified</code> header as a <code>Date</code>, if it exists.</p>
<h3 id="response-lastmodified-">response.lastModified=</h3>
<p>  Set the <code>Last-Modified</code> header as an appropriate UTC string.
  You can either set it as a <code>Date</code> or date string.</p>
<div id = "example-46"><pre><code class = "lang-js">ctx.response.lastModified = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</code></pre></div><h3 id="response-etag-">response.etag=</h3>
<p>  Set the ETag of a response including the wrapped <code>&quot;</code>s.
  Note that there is no corresponding <code>response.etag</code> getter.</p>
<div id = "example-47"><pre><code class = "lang-js">ctx.response.etag = crypto.createHash(<span class="hljs-string">'md5'</span>).update(ctx.body).digest(<span class="hljs-string">'hex'</span>);</code></pre></div><h3 id="response-vary-field-">response.vary(field)</h3>
<p>  Vary on <code>field</code>.</p>
<h3 id="response-flushheaders-">response.flushHeaders()</h3>
<p>  Flush any set headers, and begin the body.</p>
</div></section><section><div class="content"><h1 id="jobs">Jobs</h1><p>Looking for work with an amazing tech company? Check out these positions.
</p><a href="https://astro.netlify.com/automattic"><img src="https://astro.netlify.com/static/automattic.png"></a><a href="https://astro.netlify.com/segment"><img src="https://astro.netlify.com/static/segment.png"></a><a href="https://astro.netlify.com/auth0"><img src="https://astro.netlify.com/static/auth0.png"></a></div></section><section><div class="content"><h1 id="links">Links</h1><p>Community links to discover third-party middleware for Koa, full runnable examples,
thorough guides and more! If you have questions join us in IRC!
</p><ul><li><a href="https://github.com/koajs/koa">GitHub repository</a></li><li><a href="https://github.com/koajs/examples">Examples</a></li><li><a href="https://github.com/koajs/koa/wiki">Middleware</a></li><li><a href="https://github.com/koajs/koa/wiki">Wiki</a></li><li><a href="https://plus.google.com/communities/101845768320796750641">G+ Community</a></li><li><a href="https://groups.google.com/forum/#!forum/koajs">Mailing list</a></li><li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md">Guide</a></li><li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md">FAQ</a></li><li><strong>#koajs</strong> on freenode</li></ul></div></section></body></html>